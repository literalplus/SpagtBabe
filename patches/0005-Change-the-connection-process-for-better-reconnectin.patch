From 711de5d7a49182cace0330f40849963586aaa2a3 Mon Sep 17 00:00:00 2001
From: xxyy <xxyy98@gmail.com>
Date: Mon, 24 Feb 2014 23:41:01 +0100
Subject: [PATCH] Change the connection process for better reconnecting:
 Improve checking for timeouts with a PING command, Make reconnect messages
 output the connection's name, Change how reconnecting works

Signed-off-by: xxyy <devnull@nowak-at.net>
---
 core/irc.py | 110 ++++++++++++++++++++++++++++++++++++++++++++++--------------
 1 file changed, 84 insertions(+), 26 deletions(-)

diff --git a/core/irc.py b/core/irc.py
index 35d4efa..c3f34a6 100644
--- a/core/irc.py
+++ b/core/irc.py
@@ -3,6 +3,8 @@ import socket
 import time
 import thread
 import Queue
+import datetime
+import traceback
 
 from ssl import wrap_socket, CERT_NONE, CERT_REQUIRED, SSLError
 
@@ -30,23 +32,43 @@ def censor(text):
 class crlf_tcp(object):
     """Handles tcp connections that consist of utf-8 lines ending with crlf"""
 
-    def __init__(self, host, port, timeout=300):
+    def __init__(self, host, port, timeout=200, name="unknown"):
         self.ibuffer = ""
         self.obuffer = ""
         self.oqueue = Queue.Queue()  # lines to be sent out
         self.iqueue = Queue.Queue()  # lines that were received
         self.socket = self.create_socket()
+        self.socket.settimeout(timeout)
+        self.timeout = timeout
         self.host = host
         self.port = port
-        self.timeout = timeout
+        self.name = name
+        self.waitingforping = 0  # will reconnect when this is set to 3
+        self.last_timestamp = time.time()
 
     def create_socket(self):
         return socket.socket(socket.AF_INET, socket.TCP_NODELAY)
 
     def run(self):
-        self.socket.connect((self.host, self.port))
-        thread.start_new_thread(self.recv_loop, ())
-        thread.start_new_thread(self.send_loop, ())
+        #while True:
+        print 'Trying to connect to '+str(self.name)+'..'
+        try:
+            errnum = self.socket.connect_ex((self.host, self.port))
+
+            if errnum == 0:
+                print '(Re-)connected to '+str(self.name)+' successfully.'
+            else:
+                print 'Connection to '+str(self.name)+' failed. Retrying in '+str(self.timeout * 1.5)+' seconds. (err# '+str(errnum)+')'
+
+            self.waitingforping = 0
+            self.last_timestamp = time.time()
+            thread.start_new_thread(self.recv_loop, ())
+            thread.start_new_thread(self.send_loop, ())
+        except socket.error as err:
+            print str(self.name)+': Socket error occurred. Retrying in '+str(self.timeout / 2)+' seconds.', err
+            time.sleep(self.timeout / 2)
+            print "Timeout ended for "+str(self.name)+"..."
+            self.run()
 
     def recv_from_socket(self, nbytes):
         return self.socket.recv(nbytes)
@@ -54,29 +76,51 @@ class crlf_tcp(object):
     def get_timeout_exception_type(self):
         return socket.timeout
 
-    def handle_receive_exception(self, error, last_timestamp):
-        if time.time() - last_timestamp > self.timeout:
-            self.iqueue.put(StopIteration)
-            self.socket.close()
-            return True
+    def handle_receive_exception(self, error):
+        current_time = time.time()
+        if current_time - self.last_timestamp > self.timeout:
+            if self.waitingforping > 2:
+                self.iqueue.put(StopIteration)
+                self.socket.close()
+                print(datetime.datetime.now().strftime("%H:%M:%S") +
+                      "### IRC timeout occurred for "+str(self.name)+" and no ping reply...Closing connection.")
+                return True
+            else:
+                print(datetime.datetime.now().strftime("%H:%M:%S") +
+                      "### IRC timeout occurred for "+str(self.name)+" (Got last sign of life at " +
+                      datetime.datetime.fromtimestamp(self.last_timestamp).strftime('%H:%M:%S') +
+                      ")...Gently sending a PING to make sure it's not just quiet. (Iteration "+str(self.waitingforping)+")\a")
+                self.oqueue.put("PING :r u ded?")
+                self.oqueue.put("PING :r u ded?")  # send twice to make sure the server does not miss it - Yes, I know this won't help.
+                self.waitingforping += 1
+                self.last_timestamp = current_time
+                return False
+        print("IRC exception: " + traceback.format_exc())
         return False
 
     def recv_loop(self):
-        last_timestamp = time.time()
+        self.last_timestamp = time.time()
+        curr_time = time.time()
         while True:
             try:
                 data = self.recv_from_socket(4096)
                 self.ibuffer += data
                 if data:
-                    last_timestamp = time.time()
+                    self.last_timestamp = curr_time
+                    self.waitingforping = 0
                 else:
-                    if time.time() - last_timestamp > self.timeout:
+                    if curr_time - self.last_timestamp > self.timeout:
+                        self.waitingforping += 1
+                        self.oqueue.put("PING :r u ded?")
+                        print("### Semi-timeout for "+str(self.name)+" reached! ("+str(self.waitingforping)+")")
+                    elif curr_time - self.last_timestamp > (self.timeout * 1.5):
                         self.iqueue.put(StopIteration)
                         self.socket.close()
+                        print("### IRC timeout occurred for "+str(self.name)+" (Got last sign of life at "+datetime.datetime.fromtimestamp(self.last_timestamp).strftime('%H:%M:%S')+")\a\a!")
                         return
                     time.sleep(1)
             except (self.get_timeout_exception_type(), socket.error) as e:
-                if self.handle_receive_exception(e, last_timestamp):
+                if self.handle_receive_exception(e):
                     return
                 continue
 
@@ -87,19 +131,24 @@ class crlf_tcp(object):
     def send_loop(self):
         while True:
             line = self.oqueue.get().splitlines()[0][:500]
-            print ">>> %r" % line
+            print u"%s >>> %r -> %s" % (datetime.datetime.fromtimestamp(self.last_timestamp).strftime('%H:%M:%S'), line, self.name)
             self.obuffer += line.encode('utf-8', 'replace') + '\r\n'
             while self.obuffer:
-                sent = self.socket.send(self.obuffer)
-                self.obuffer = self.obuffer[sent:]
+                try:
+                    sent = self.socket.send(self.obuffer)
+                    self.obuffer = self.obuffer[sent:]
+                except socket.error as err:
+                    print u"Couldn't send output buffer: %s - Closing connection." % err.message
+                    self.socket.close()
+                    self.iqueue.put(StopIteration)
 
 
 class crlf_ssl_tcp(crlf_tcp):
     """Handles ssl tcp connetions that consist of utf-8 lines ending with crlf"""
 
-    def __init__(self, host, port, ignore_cert_errors, timeout=300):
+    def __init__(self, host, port, ignore_cert_errors, timeout=200, name="unknown"):
         self.ignore_cert_errors = ignore_cert_errors
-        crlf_tcp.__init__(self, host, port, timeout)
+        crlf_tcp.__init__(self, host, port, timeout, name)
 
     def create_socket(self):
         return wrap_socket(crlf_tcp.create_socket(self), server_side=False,
@@ -112,11 +161,15 @@ class crlf_ssl_tcp(crlf_tcp):
     def get_timeout_exception_type(self):
         return SSLError
 
-    def handle_receive_exception(self, error, last_timestamp):
+    def handle_receive_exception(self, error):
         # this is terrible
-        if not "timed out" in error.args[0]:
-            raise
-        return crlf_tcp.handle_receive_exception(self, error, last_timestamp)
+        try:
+            if not "timed out" in error.args[0]:
+                raise
+        except TypeError:
+            pass
+
+        return crlf_tcp.handle_receive_exception(self, error)
 
 
 irc_prefix_rem = re.compile(r'(.*?) (.*?) (.*)').match
@@ -137,6 +190,8 @@ class IRC(object):
         self.nick = nick
         self.history = {}
         self.vars = {}
+        self.waitstart = -1  # If > 0 denotes the time this connection sent a PING request to the IRC server. The connection will be re-established if no response is received after a timeout.
+        self.timeout = 300  # Might need to change that dynamically later
 
         self.out = Queue.Queue()  # responses from the server are placed here
         # format: [rawline, prefix, command, params,
@@ -146,7 +201,7 @@ class IRC(object):
         thread.start_new_thread(self.parse_loop, ())
 
     def create_connection(self):
-        return crlf_tcp(self.server, self.port)
+        return crlf_tcp(self.server, self.port, self.timeout, self.name)
 
     def connect(self):
         self.conn = self.create_connection()
@@ -163,9 +218,12 @@ class IRC(object):
             msg = self.conn.iqueue.get()
 
             if msg == StopIteration:
+                print("Reconnecting to "+str(self.name)+" because of StopIteration...")
                 self.connect()
+                #self.waitstart = time.time()
+                #self.cmd("PING", "ruded")
+                #print "um...I got a StopIteration there...Politely pinging "+str(self.name)+" now."
                 continue
-
             # parse the message
             if msg.startswith(":"):  # has a prefix
                 prefix, command, params = irc_prefix_rem(msg).groups()
@@ -232,4 +290,4 @@ class SSLIRC(IRC):
         IRC.__init__(self, name, server, nick, port, channels, conf)
 
     def create_connection(self):
-        return crlf_ssl_tcp(self.server, self.port, self.ignore_cert_errors)
+        return crlf_ssl_tcp(self.server, self.port, self.ignore_cert_errors, self.timeout, self.name)
-- 
1.8.3.msysgit.0

